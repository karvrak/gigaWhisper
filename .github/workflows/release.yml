name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  # Force compatible CPU target to avoid illegal instruction errors
  RUSTFLAGS: "-C target-cpu=x86-64-v2"

jobs:
  # ============================================
  # Create Release Draft
  # ============================================
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create_release.outputs.result }}
      version: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.get_version.outputs.VERSION }}`,
              name: `GigaWhisper v${{ steps.get_version.outputs.VERSION }}`,
              body: `## What's Changed\n\nSee the [full changelog](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/v${{ steps.get_version.outputs.VERSION }}...HEAD)\n\n## Installation\n\nDownload the installer for your system:\n\n| Variant | Description | Download |\n|---------|-------------|----------|\n| **CPU** | Works on all systems | \`GigaWhisper_${{ steps.get_version.outputs.VERSION }}_x64-cpu-setup.exe\` |\n| **Vulkan** | GPU acceleration (AMD/Intel/NVIDIA) | \`GigaWhisper_${{ steps.get_version.outputs.VERSION }}_x64-vulkan-setup.exe\` |\n| **CUDA** | Best for NVIDIA GPUs | \`GigaWhisper_${{ steps.get_version.outputs.VERSION }}_x64-cuda-setup.exe\` |\n\n## Auto-Update\n\nIf you already have GigaWhisper installed, you'll be prompted to update automatically (same variant).`,
              draft: true,
              prerelease: false
            })
            return data.id

  # ============================================
  # Build Windows (3 variants)
  # ============================================
  build-windows:
    name: Build Windows (${{ matrix.variant }})
    needs: create-release
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - variant: cpu
            features: ""
            artifact_suffix: "cpu"
          - variant: vulkan
            features: "--features gpu-vulkan"
            artifact_suffix: "vulkan"
          - variant: cuda
            features: "--features gpu-cuda"
            artifact_suffix: "cuda"

    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          key: ${{ matrix.variant }}-v3
          # Fresh cache - v3 to clear corrupted artifact names

      # CUDA setup (only for cuda variant)
      - name: Setup CUDA
        if: matrix.variant == 'cuda'
        uses: Jimver/cuda-toolkit@v0.2.16
        with:
          cuda: '12.4.0'
          method: 'network'
          sub-packages: '["nvcc", "cudart", "cublas", "cublas_dev", "visual_studio_integration"]'

      # Copy CUDA DLLs for bundling (only for cuda variant)
      - name: Copy CUDA DLLs
        if: matrix.variant == 'cuda'
        shell: pwsh
        run: |
          $cudaPath = $env:CUDA_PATH
          Write-Host "CUDA_PATH: $cudaPath"

          # Create resources directory
          $resourcesDir = "src-tauri/resources"
          New-Item -ItemType Directory -Force -Path $resourcesDir

          # Copy CUDA runtime DLLs
          $dllsToCopy = @(
            "cudart64_12.dll",
            "cublas64_12.dll",
            "cublasLt64_12.dll"
          )

          foreach ($dll in $dllsToCopy) {
            $sourcePath = Join-Path $cudaPath "bin" $dll
            if (Test-Path $sourcePath) {
              Copy-Item $sourcePath $resourcesDir -Force
              Write-Host "Copied $dll"
            } else {
              Write-Host "Warning: $dll not found at $sourcePath"
              # Try alternative names for different CUDA versions
              $altDll = $dll -replace "64_12", "64_*"
              $found = Get-ChildItem -Path (Join-Path $cudaPath "bin") -Filter $altDll -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) {
                Copy-Item $found.FullName $resourcesDir -Force
                Write-Host "Copied alternative: $($found.Name)"
              }
            }
          }

          # List copied DLLs
          Write-Host "Resources directory contents:"
          Get-ChildItem $resourcesDir

          # Update tauri.conf.json to include CUDA DLLs
          $tauriConf = Get-Content "src-tauri/tauri.conf.json" -Raw | ConvertFrom-Json
          $tauriConf.bundle.resources = @{ "resources/*.dll" = "./" }
          $tauriConf | ConvertTo-Json -Depth 20 | Set-Content "src-tauri/tauri.conf.json" -Encoding UTF8
          Write-Host "Updated tauri.conf.json to include CUDA DLLs"

      # Vulkan SDK setup (only for vulkan variant)
      - name: Setup Vulkan SDK
        if: matrix.variant == 'vulkan'
        uses: jakoch/install-vulkan-sdk-action@v1.0.4
        with:
          vulkan_version: 1.3.290.0
          install_runtime: true
          cache: true
          destination: ${{ github.workspace }}/vulkan-sdk

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Tauri App
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          # Don't use releaseId to prevent auto-upload (we rename and upload manually)
          args: ${{ matrix.features }}

      # Rename artifacts to include variant
      - name: Rename artifacts
        shell: pwsh
        run: |
          $version = "${{ needs.create-release.outputs.version }}"
          $variant = "${{ matrix.variant }}"
          $releaseDir = "src-tauri/target/release/bundle/nsis"

          Write-Host "Looking for NSIS installer in: $releaseDir"
          Write-Host "All files in directory:"
          Get-ChildItem -Path $releaseDir -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }

          # Find NSIS installer (exclude already renamed files)
          $nsisFile = Get-ChildItem -Path $releaseDir -Filter "*.exe" | Where-Object { $_.Name -notmatch "-cpu-|-vulkan-|-cuda-" } | Select-Object -First 1

          if ($nsisFile) {
            $newName = "GigaWhisper_${version}_x64-${variant}-setup.exe"
            $newPath = Join-Path $releaseDir $newName
            Write-Host "Found: $($nsisFile.Name)"
            Write-Host "Renaming to: $newName"
            Move-Item $nsisFile.FullName $newPath -Force
            Write-Host "Renamed successfully"

            # Also rename the signature file
            $sigFile = "$($nsisFile.FullName).sig"
            if (Test-Path $sigFile) {
              Move-Item $sigFile "$newPath.sig" -Force
              Write-Host "Renamed signature file"
            }
          } else {
            Write-Host "ERROR: No NSIS installer found!"
            Write-Host "Available .exe files:"
            Get-ChildItem -Path $releaseDir -Filter "*.exe" | ForEach-Object { Write-Host "  $($_.Name)" }
            exit 1
          }

      # Upload renamed artifacts to release
      - name: Upload artifacts to release
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $version = "${{ needs.create-release.outputs.version }}"
          $variant = "${{ matrix.variant }}"
          $releaseDir = "src-tauri/target/release/bundle/nsis"

          Write-Host "Uploading artifacts for variant: $variant"

          # Upload NSIS installer
          $exeFile = Join-Path $releaseDir "GigaWhisper_${version}_x64-${variant}-setup.exe"
          Write-Host "Looking for: $exeFile"

          if (Test-Path $exeFile) {
            Write-Host "File found, uploading..."
            gh release upload "v${version}" $exeFile --clobber
            Write-Host "Uploaded $exeFile"
          } else {
            Write-Host "ERROR: File not found: $exeFile"
            Write-Host "Available files in $releaseDir :"
            Get-ChildItem -Path $releaseDir | ForEach-Object { Write-Host "  $($_.Name)" }
            exit 1
          }

          # Upload signature
          $sigFile = "$exeFile.sig"
          if (Test-Path $sigFile) {
            gh release upload "v${version}" $sigFile --clobber
            Write-Host "Uploaded signature: $sigFile"
          } else {
            Write-Host "Warning: Signature file not found: $sigFile"
          }

      # Generate latest-{variant}.json
      - name: Generate update manifest
        shell: pwsh
        run: |
          $version = "${{ needs.create-release.outputs.version }}"
          $variant = "${{ matrix.variant }}"
          $releaseDir = "src-tauri/target/release/bundle/nsis"

          # Read signature
          $sigFile = Join-Path $releaseDir "GigaWhisper_${version}_x64-${variant}-setup.exe.sig"
          $signature = ""
          if (Test-Path $sigFile) {
            $signature = Get-Content $sigFile -Raw
            $signature = $signature.Trim()
          }

          # Create latest-{variant}.json
          $manifest = @{
            version = $version
            notes = "GigaWhisper v${version} (${variant})"
            pub_date = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
            platforms = @{
              "windows-x86_64" = @{
                signature = $signature
                url = "https://github.com/${{ github.repository }}/releases/download/v${version}/GigaWhisper_${version}_x64-${variant}-setup.exe"
              }
            }
          }

          $manifestJson = $manifest | ConvertTo-Json -Depth 10
          $manifestFile = "latest-${variant}.json"
          $manifestJson | Out-File -FilePath $manifestFile -Encoding utf8
          Write-Host "Generated $manifestFile"
          Get-Content $manifestFile

      - name: Upload update manifest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "v${{ needs.create-release.outputs.version }}" "latest-${{ matrix.variant }}.json" --clobber

  # ============================================
  # Publish Release
  # ============================================
  publish-release:
    name: Publish Release
    needs: [create-release, build-windows]
    runs-on: ubuntu-latest
    steps:
      - name: Publish Release
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.create-release.outputs.release_id }},
              draft: false
            })
